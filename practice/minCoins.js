// 动态规划
// 题目1：

// 如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？

// 分析：

// 我们用d(i)=j来表示凑够i元最少需要j个硬币。于是我们已经得到了d(0)=0， 表示凑够0元最小需要0个硬币。当i=1时，只有面值为1元的硬币可用， 因此我们拿起一个面值为1的硬币，接下来只需要凑够0元即可。所以，d(1)=d(1-1)+1=d(0)+1=0+1=1。当i=2时， 仍然只有面值为1的硬币可用，于是我拿起一个面值为1的硬币， 接下来我只需要再凑够2-1=1元即可。 所以d(2)=d(2-1)+1=d(1)+1=1+1=2。当i=3时，我们能用的硬币就有两种了：1元的和3元的既然能用的硬币有两种，我就有两种方案。如果我拿了一个1元的硬币，我的目标就变为了： 凑够3-1=2元需要的最少硬币数量。即d(3)=d(3-1)+1=d(2)+1=2+1=3。 这个方案说的是，我拿3个1元的硬币；第二种方案是我拿起一个3元的硬币， 我的目标就变成：凑够3-3=0元需要的最少硬币数量。即d(3)=d(3-3)+1=d(0)+1=0+1=1. 这个方案说的是，我拿1个3元的硬币。要用最少的硬币数量来凑够3元，所以， 选择d(3)=1，怎么来的呢？具体是这样得到的：d(3)=min{d(3-1)+1, d(3-3)+1}。

// d(i)表示凑够i元需要的最少硬币数量，我们将它定义为该问题的”状态”，按照上面的规律可以得到状态转移方程：d(i)=min{ d(i-vj)+1 }，其中i-vj >=0，vj表示第j个硬币的面值

function min(arr) {
    let min = arr[0]
    for(let i = 1; i < arr.length ; i++) {
      if(arr[i] < min) min = arr[i]
    }
    return min
  }
const jarr = [1 ,3 ,5]
// 递归，爆栈
// function dp(n) {
// 	if (n <= 0) return 0
//   const	arr = []
//   for(j of jarr) {
//     const res = dp(n - j)+1
//     arr.push(res)
//   }
// 	return min(arr)
// }

// 改为循环
function dp(n) {
const	map = new Map()
map.set(0, 0)
for(let i = 1; i <= n; i++) {
    const	arr = []
    for(j of jarr) {
    const last = map.get(i - j)
    const res = last + 1
    arr.push(res)
    }
    map.set(i, min(arr))
}
    return map.get(n)
}