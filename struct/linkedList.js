// LRU缓存淘汰算法

// 当缓存被⽤满时就需要缓存淘汰策略来决定。常⻅的有三种：先进先出策略FIFO（First In，First Out）、最少使⽤策略LFU（Least Frequently Used）、最近最少使⽤策略LRU（Least Recently Used）。

// 从底层的存储结构来看：它通过“指针”将⼀组零散的内存块串联起来使⽤，其中，我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下⼀个结点的地址。这个记录下个结点地址的指针叫作后继指针next。

// 单链表
// 头结点⽤来记录链表的基地址。有了它，我们就可以遍历得到整条链表。
// 尾结点的指针不是指向下⼀个结点，⽽是指向⼀个空地址NULL，表示这是链表上最后⼀个结点。
// 插入和删除：因为链表的存储空间本身就不是连续的。所以，在链表中插⼊和删除⼀个数据是⾮常快速的。对应的时间复杂度是O(1)。
// 随机访问：因为链表中的数据并⾮连续存储的，需要根据指针⼀个结点⼀个结点地依次遍历，直到找到相应的结点。

// 循环链表
// ⼀种特殊的单链表。它跟单链表唯⼀的区别就在尾结点。循环链表的尾结点指针是指向链表的头结点。它像⼀个环⼀样⾸尾相连，所以叫作“循环”链表。
// 循环链表的优点是从链尾到链头⽐较⽅便。当要处理的数据具有环型结构特点时，就特别适合采⽤循环链表。⽐如著名的约瑟夫问题。

// 双向链表
// 它⽀持两个⽅向，每个结点不⽌有⼀个后继指针next指向后⾯的结点，还有⼀个前驱指针prev指向前⾯的结点。
// 双向链表要⽐单链表占⽤更多的内存空间。虽然两个指针⽐较浪费存储空间，但可以⽀持双向遍历，这样也带来了双向链表操作的灵活性。
// 插入和删除：
// 删除结点中“值等于某个给定值”的结点：从头结点开始⼀个⼀个依次遍历对⽐，直到找到值等于给定值的结点，然后再指针操作将其删除。对应的时间复杂度为O(n)。
// 删除给定指针指向的结点：我们已经找到了要删除的结点，删除某个结点q需要知道其前驱结点，对于双向列表来说是已知的，所以时间复杂度为O(1)
// Java中的LinkedHashMap这个容器的实现原理，其中就⽤到了双向链表这种数据结构。

// 双向循环链表

// 数组和链表
// 两种截然不同的内存组织⽅式。正是因为内存存储的区别，它们插⼊、删除、随机访问操作的时间复杂度正好相反。
// 数组简单易⽤，在实现上使⽤的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更⾼。
// 链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。
// 数组的缺点是⼤⼩固定，⼀经声明就要占⽤整块连续内存空间。如果声明的数组过⼤，可能导致“内存不⾜（out of memory）”。如果声明的数组过⼩，则可能出现不够⽤的情况。这时只能再申请⼀个更⼤的内存空间，把原数组拷⻉进去，⾮常费时。
// 链表本身没有⼤⼩的限制，天然地⽀持动态扩容，这也是它与数组最⼤的区别。

