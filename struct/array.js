// 定义:线性表数据结构.用一组连续的内存空间存储一组相同类型的数据

// 线性表:数据排列成线一样的结构,每个数据最多有前后两个方向.比如:栈,链表,队列等
// 非线性表:数据之间不是简单的前后关系
// 连续的内存空间和型同类型的数据:有随机访问的特性,但也让很多操作变得低效,比如删除和插入

// 插入:
// 有序:每个位置插入的时间复杂度是n
// 无序:只当作一个存储集合,可以插入到固定位置k,将k位置的元素放到最后,时间复杂度是1

// 删除:
// 和插入类似
// 在一些特殊场景下,不一定追求连续性,将多次删除操作一起执行可以提高效率,比如只是记录数据已经被删除,在没有更多的空间时,一次性删除,也是JVM标记清除垃圾回收机制的核心思想

// 数组的访问越界
// 在C中是⼀种未决⾏为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问⼀段连续内存，只要数组通过偏移计算得到的内存地址是可⽤的，那么程序就可能不会报任何错误。
// 很多计算机病毒也正是利⽤到了代码中的数组越界可以访问⾮法地址的漏洞，来攻击系统，所以写代码的时候⼀定要警惕数组越界。
// Java本身就会做越界检查，会抛出java.lang.ArrayIndexOutOfBoundsException。

// 容器：针对数组类型，很多语⾔都提供了容器类，⽐如Java中的ArrayList、C++ STL中的vector。
// ArrayList最⼤的优势就是可以将很多数组操作的细节封装起来。⽐如前⾯提到的数组插⼊、删除数据时需要搬移其他数据等。另外，它还有⼀个优势，就是⽀持动态扩容。每次存储空间不够的时候，它都会将空间⾃动扩容为1.5倍⼤⼩。这⾥需要注意⼀点，因为扩容操作涉及内存申请和数据搬移，是⽐较耗时的。所以，最好在创建ArrayList的时候事先指定数据⼤⼩。
// 1.Java ArrayList⽆法存储基本类型，⽐如int、long，需要封装为Integer、Long类，⽽Autoboxing、Unboxing则有⼀定的性能消耗，所以如果特别关注性能，或者希望使⽤基本类型，就可以选⽤数组。
// 2.如果数据⼤⼩事先已知，并且对数据的操作⾮常简单，⽤不到ArrayList提供的⼤部分⽅法，也可以直接使⽤数组。
// 3.当要表示多维数组时，⽤数组往往会更加直观。⽐如Object[][] array；⽽⽤容器的话则需要这样定义：ArrayList<ArrayList > array。
// 总结：如果是做⼀些⾮常底层的开发，⽐如开发⽹络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为⾸选。

// 为什么⼤多数编程语⾔中，数组要从0开始编号，⽽不是从1开始呢？
// 从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前⾯也讲到，如果⽤a来表示数组的⾸地址，a[0]就是偏移为0的位置，也就是⾸地址
// 计算a[k]的内存地址只需要⽤这个公式：a[k]_address = base_address + (k-1)*type_size
// C语⾔设计者⽤0开始计数数组下标，之后的Java、JavaScript等⾼级语⾔都效仿了C语⾔，为了减少学习成本



